const Tesseract = require('tesseract.js');
const sharp = require('sharp');
const fs = require('fs').promises;
const path = require('path');

const { createBotLogger } = require('../../utils/consoleLogger');

const logger = createBotLogger('Kontroler');
class OCRService {
    constructor(config) {
        this.config = config;
        this.ensureDirectories();
    }

    /**
     * Tworzy niezbƒôdne katalogi
     */
    async ensureDirectories() {
        try {
            if (this.config.ocr.saveProcessedImages) {
                await fs.mkdir(this.config.ocr.processedDir, { recursive: true });
            }
            await fs.mkdir(this.config.ocr.tempDir, { recursive: true });
        } catch (error) {
            logger.error(`B≈ÇƒÖd tworzenia katalog√≥w: ${error.message}`);
        }
    }

    /**
     * Sprawdza czy piksel jest bia≈Çy lub bardzo jasny
     * @param {number} r - Warto≈õƒá czerwona
     * @param {number} g - Warto≈õƒá zielona
     * @param {number} b - Warto≈õƒá niebieska
     * @param {number} threshold - Pr√≥g jasno≈õci
     * @returns {boolean} - Czy piksel jest jasny
     */
    isWhiteOrNearWhite(r, g, b, threshold = 200) {
        return r >= threshold && g >= threshold && b >= threshold;
    }

    /**
     * Preprocessing obrazu - r√≥≈ºne metody dla r√≥≈ºnych kana≈Ç√≥w
     * @param {string} imagePath - ≈öcie≈ºka do obrazu
     * @param {Object} channelConfig - Konfiguracja kana≈Çu
     * @returns {string} - ≈öcie≈ºka do przetworzonego obrazu
     */
    async preprocessImage(imagePath, channelConfig) {
        logger.info('Rozpoczynam preprocessing obrazu...');
        
        try {
            const outputPath = imagePath.replace(/\.(png|jpg|jpeg)$/i, '_processed.png');
            
            if (channelConfig.name === 'Daily') {
                logger.info('Daily - u≈ºywam metody dla bia≈Çego tekstu na szarym tle');
                return await this.preprocessWhiteTextOnGray(imagePath, outputPath);
            } else {
                logger.info('CX - u≈ºywam zaawansowanej konwersji bia≈Ço-czarnej');
                return await this.preprocessBlackWhite(imagePath, outputPath);
            }
        } catch (error) {
            logger.error(`B≈ÇƒÖd preprocessingu: ${error.message}`);
            throw error;
        }
    }

    /**
     * Preprocessing dla bia≈Çego tekstu na szarym tle (Daily) - ustawienia z Rekrutera dla ataku
     * @param {string} imagePath - ≈öcie≈ºka do obrazu
     * @param {string} outputPath - ≈öcie≈ºka wyj≈õciowa
     * @returns {string} - ≈öcie≈ºka do przetworzonego obrazu
     */
    async preprocessWhiteTextOnGray(imagePath, outputPath) {
        logger.info('U≈ºycie ustawie≈Ñ OCR z Rekrutera dla ataku z korekcjƒÖ gamma 3.0 + redukcja szum√≥w + delikatne rozmycie');
        
        await sharp(imagePath)
            .gamma(3.0)
            .median(3)
            .blur(0.5)
            .grayscale()
            .threshold(200)
            .negate()
            .png()
            .toFile(outputPath);
        
        // Zapisz przetworzone zdjƒôcie na dysku je≈õli w≈ÇƒÖczone
        if (this.config.ocr.saveProcessedImages) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `daily_processed_${timestamp}.png`;
            const savedPath = path.join(this.config.ocr.processedDir, filename);
            
            try {
                await fs.copyFile(outputPath, savedPath);
                logger.info(`üíæ Zapisano przetworzone zdjƒôcie Daily: ${filename}`);
            } catch (error) {
                logger.error(`B≈ÇƒÖd zapisu przetworzonego zdjƒôcia: ${error.message}`);
            }
        }
        
        logger.info('Preprocessing dla bia≈Çego tekstu zako≈Ñczony (styl Rekruter - atak + gamma 3.0 + redukcja szum√≥w + rozmycie)');
        return outputPath;
    }

    /**
     * Preprocessing bia≈Ço-czarny (CX)
     * @param {string} imagePath - ≈öcie≈ºka do obrazu
     * @param {string} outputPath - ≈öcie≈ºka wyj≈õciowa
     * @returns {string} - ≈öcie≈ºka do przetworzonego obrazu
     */
    async preprocessBlackWhite(imagePath, outputPath) {
        const { data, info } = await sharp(imagePath)
            .gamma(this.config.ocr.gamma)
            .raw()
            .toBuffer({ resolveWithObject: true });
        
        logger.info(`Informacje o obrazie: ${info.width}x${info.height}, ${info.channels} kana≈Çy, ${Math.round(data.length / 1024)}KB`);

        let whitePixels = 0;
        let blackPixels = 0;
        
        for (let i = 0; i < data.length; i += info.channels) {
            const r = data[i];
            const g = data[i + 1];
            const b = data[i + 2];
            
            if (this.isWhiteOrNearWhite(r, g, b, 180)) {
                data[i] = 255;
                data[i + 1] = 255;
                data[i + 2] = 255;
                whitePixels++;
            } else {
                data[i] = 0;
                data[i + 1] = 0;
                data[i + 2] = 0;
                blackPixels++;
            }
        }

        const totalPixels = whitePixels + blackPixels;
        const whitePercentage = ((whitePixels / totalPixels) * 100).toFixed(1);
        logger.info(`Pikseli bia≈Çych: ${whitePixels} (${whitePercentage}%), czarnych: ${blackPixels}`);

        await sharp(data, {
            raw: {
                width: info.width,
                height: info.height,
                channels: info.channels
            }
        })
        .png()
        .toFile(outputPath);

        // Zapisz przetworzone zdjƒôcie na dysku je≈õli w≈ÇƒÖczone
        if (this.config.ocr.saveProcessedImages) {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const filename = `cx_processed_${timestamp}.png`;
            const savedPath = path.join(this.config.ocr.processedDir, filename);
            
            try {
                await fs.copyFile(outputPath, savedPath);
                logger.info(`üíæ Zapisano przetworzone zdjƒôcie CX: ${filename}`);
            } catch (error) {
                logger.error(`B≈ÇƒÖd zapisu przetworzonego zdjƒôcia: ${error.message}`);
            }
        }

        logger.info('Zaawansowany preprocessing zako≈Ñczony');
        return outputPath;
    }

    /**
     * Rozpoznaje tekst z obrazu
     * @param {string} imagePath - ≈öcie≈ºka do obrazu
     * @returns {string} - Rozpoznany tekst
     */
    async extractTextFromImage(imagePath) {
        logger.info('Rozpoczynam rozpoznawanie tekstu OCR...');
        
        const { data: { text } } = await Tesseract.recognize(imagePath, this.config.ocr.languages, {
            tessedit_char_whitelist: this.config.ocr.charWhitelist,
            tessedit_pageseg_mode: Tesseract.PSM.AUTO,
            tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
            textord_heavy_nr: '1',
            textord_debug_tabfind: '0',
            classify_bln_numeric_mode: '1'
        });

        logger.info(`Rozpoznany tekst: "${text.trim()}"`);

        return text;
    }

    /**
     * Normalizuje wynik z tekstu
     * @param {string} scoreText - Tekst wyniku
     * @param {Object} channelConfig - Konfiguracja kana≈Çu
     * @returns {Object} - Znormalizowany wynik
     */
    normalizeScore(scoreText, channelConfig) {
        logger.info(`Normalizacja wyniku: "${scoreText}"`);
        
        // Specjalne wyjƒÖtki dla Daily
        if (channelConfig.name === 'Daily') {
            // WyjƒÖtek 1: "sg" -> "9"
            if (scoreText.toLowerCase().includes('sg')) {
                logger.info('DAILY: Wykryto "sg" - zamieniam na "9"');
                scoreText = scoreText.toLowerCase().replace(/sg/g, '9');
            }
            
            // WyjƒÖtek 2: "&" i "& " -> "9" (przed dwucyfrowym wynikiem)
            if (scoreText.includes('&')) {
                logger.info('DAILY: Wykryto "&" - zamieniam na "9"');
                scoreText = scoreText.replace(/& /g, '9').replace(/&/g, '9');
            }
        }

        let normalized = scoreText;
        
        // Podstawowe zamienniki
        for (const [char, digit] of Object.entries(this.config.charReplacements)) {
            normalized = normalized.replace(new RegExp(char, 'g'), digit);
        }

        // Specjalne traktowanie 's' i 'S'
        if (normalized.includes('s') || normalized.includes('S')) {
            logger.info('Wykryto s/S - testujƒô warianty 5 i 8');
            
            const variant5Text = normalized.replace(/[sS]/g, '5');
            const variant5Numbers = variant5Text.match(/\d+/g);
            const variant5 = variant5Numbers ? variant5Numbers.join('') : '';
            
            const variant8Text = normalized.replace(/[sS]/g, '8');
            const variant8Numbers = variant8Text.match(/\d+/g);
            const variant8 = variant8Numbers ? variant8Numbers.join('') : '';
            
            return {
                hasVariants: true,
                variant5: variant5,
                variant8: variant8,
                original: scoreText
            };
        }

        const numbersOnly = normalized.match(/\d+/g);
        const finalResult = numbersOnly ? numbersOnly.join('') : '';
        
        logger.info(`Wynik po normalizacji: "${finalResult}"`);
        
        return {
            hasVariants: false,
            normalized: finalResult,
            original: scoreText
        };
    }
}

module.exports = OCRService;