const fs = require('fs').promises;
const path = require('path');
const { createBotLogger } = require('../../utils/consoleLogger');

const logger = createBotLogger('Wydarzynier');

class TimerService {
    constructor(config) {
        this.config = config;
        this.activeTimers = new Map(); // Mapa aktywnych timer√≥w
        this.dataPath = path.join(__dirname, '../data/timers.json');
        this.ensureDataDirectory();
    }

    /**
     * Zapewnia istnienie katalogu data
     */
    async ensureDataDirectory() {
        const dataDir = path.dirname(this.dataPath);
        try {
            await fs.mkdir(dataDir, { recursive: true });
        } catch (error) {
            if (error.code !== 'EEXIST') {
                logger.error('‚ùå B≈ÇƒÖd podczas tworzenia katalogu data:', error);
            }
        }
    }

    /**
     * Tworzy timer dla lobby z ostrze≈ºeniem i zamkniƒôciem
     * @param {string} lobbyId - ID lobby
     * @param {number} createdAt - Timestamp utworzenia lobby
     * @param {Function} warningCallback - Funkcja wywo≈Çywana przy ostrze≈ºeniu
     * @param {Function} deleteCallback - Funkcja wywo≈Çywana przy usuniƒôciu
     */
    async createLobbyTimer(lobbyId, createdAt, warningCallback, deleteCallback) {
        const now = Date.now();
        const warningTime = createdAt + this.config.lobby.maxDuration - this.config.lobby.warningTime;
        const deleteTime = createdAt + this.config.lobby.maxDuration;

        // Sprawd≈∫ czy ostrze≈ºenie ju≈º minƒô≈Ço
        const warningDelay = Math.max(0, warningTime - now);
        const deleteDelay = Math.max(0, deleteTime - now);

        // Je≈õli czas ju≈º minƒÖ≈Ç, usu≈Ñ lobby od razu
        if (deleteDelay === 0) {
            logger.info(`‚è∞ Timer lobby ${lobbyId} ju≈º wygas≈Ç - usuwanie od razu`);
            if (deleteCallback) {
                await deleteCallback();
            }
            return;
        }

        const timerData = {
            lobbyId,
            createdAt,
            warningTime,
            deleteTime,
            warningExecuted: warningDelay === 0,
            isFullLobby: false // Oznacza czy lobby jest pe≈Çne i ma skr√≥cony timer
        };

        // Ustaw timer ostrze≈ºenia (je≈õli jeszcze nie minƒÖ≈Ç)
        if (warningDelay > 0) {
            const warningTimer = setTimeout(async () => {
                logger.info(`‚ö†Ô∏è Wysy≈Çanie ostrze≈ºenia dla lobby ${lobbyId}`);
                timerData.warningExecuted = true;
                await this.saveTimersToFile();
                if (warningCallback) {
                    await warningCallback(lobbyId); // Przeka≈º lobbyId do callback
                }
            }, warningDelay);

            timerData.warningTimer = warningTimer;
        }

        // Ustaw timer usuniƒôcia
        const deleteTimer = setTimeout(async () => {
            logger.info(`üóëÔ∏è Usuwanie lobby ${lobbyId} - czas minƒÖ≈Ç`);
            if (deleteCallback) {
                await deleteCallback();
            }
            this.removeTimer(lobbyId);
        }, deleteDelay);

        timerData.deleteTimer = deleteTimer;
        this.activeTimers.set(lobbyId, timerData);

        // Zapisz do pliku
        await this.saveTimersToFile();

        logger.info(`‚è∞ Utworzono timer dla lobby ${lobbyId} - ostrze≈ºenie za ${Math.round(warningDelay/1000/60)}min, usuniƒôcie za ${Math.round(deleteDelay/1000/60)}min`);
    }

    /**
     * Tworzy skr√≥cony timer 15 minut dla pe≈Çnego lobby
     * @param {string} lobbyId - ID lobby
     * @param {Function} warningCallback - Funkcja wywo≈Çywana przy ostrze≈ºeniu
     * @param {Function} deleteCallback - Funkcja wywo≈Çywana przy usuniƒôciu
     */
    async createFullLobbyTimer(lobbyId, warningCallback, deleteCallback) {
        // Usu≈Ñ istniejƒÖcy timer je≈õli istnieje
        this.removeTimer(lobbyId);

        const now = Date.now();
        const fullLobbyDuration = this.config.lobby.fullLobbyDuration; // 15 minut
        const warningTime = now + fullLobbyDuration - this.config.lobby.warningTime; // 5 minut przed ko≈Ñcem
        const deleteTime = now + fullLobbyDuration;

        const warningDelay = Math.max(0, warningTime - now);
        const deleteDelay = Math.max(0, deleteTime - now);

        const timerData = {
            lobbyId,
            createdAt: now,
            warningTime,
            deleteTime,
            warningExecuted: warningDelay === 0,
            isFullLobby: true // Oznacza ≈ºe to timer dla pe≈Çnego lobby
        };

        // Ustaw timer ostrze≈ºenia (je≈õli jeszcze nie minƒÖ≈Ç)
        if (warningDelay > 0) {
            const warningTimer = setTimeout(async () => {
                logger.info(`‚ö†Ô∏è Wysy≈Çanie ostrze≈ºenia dla pe≈Çnego lobby ${lobbyId}`);
                timerData.warningExecuted = true;
                await this.saveTimersToFile();
                if (warningCallback) {
                    await warningCallback(lobbyId); // Przeka≈º lobbyId do callback
                }
            }, warningDelay);

            timerData.warningTimer = warningTimer;
        }

        // Ustaw timer usuniƒôcia
        const deleteTimer = setTimeout(async () => {
            logger.info(`üóëÔ∏è Usuwanie pe≈Çnego lobby ${lobbyId} - czas 15 minut minƒÖ≈Ç`);
            if (deleteCallback) {
                await deleteCallback();
            }
            this.removeTimer(lobbyId);
        }, deleteDelay);

        timerData.deleteTimer = deleteTimer;
        this.activeTimers.set(lobbyId, timerData);

        // Zapisz do pliku
        await this.saveTimersToFile();

        logger.info(`‚è∞ Utworzono timer 15 minut dla pe≈Çnego lobby ${lobbyId} - ostrze≈ºenie za ${Math.round(warningDelay/1000/60)}min, usuniƒôcie za ${Math.round(deleteDelay/1000/60)}min`);
    }

    /**
     * Usuwa timer dla lobby
     * @param {string} lobbyId - ID lobby
     */
    removeTimer(lobbyId) {
        const timerData = this.activeTimers.get(lobbyId);
        if (timerData) {
            if (timerData.warningTimer) {
                clearTimeout(timerData.warningTimer);
            }
            if (timerData.deleteTimer) {
                clearTimeout(timerData.deleteTimer);
            }
            this.activeTimers.delete(lobbyId);
            
            // Aktualizuj plik
            this.saveTimersToFile().catch(error => {
                logger.error('‚ùå B≈ÇƒÖd podczas zapisywania timer√≥w po usuniƒôciu:', error);
            });
            
            logger.info(`üóëÔ∏è Usuniƒôto timer dla lobby ${lobbyId}`);
        }
    }

    /**
     * Przywraca timery po restarcie bota
     * @param {Object} sharedState - Wsp√≥≈Çdzielony stan aplikacji
     */
    async restoreTimers(sharedState) {
        try {
            await this.loadTimersFromFile();
            
            const now = Date.now();
            const timersToRestore = [];

            for (const [lobbyId, timerData] of this.activeTimers.entries()) {
                // Sprawd≈∫ czy lobby nadal istnieje
                const lobby = sharedState.lobbyService.getLobby(lobbyId);
                if (!lobby) {
                    logger.warn(`‚ö†Ô∏è Lobby ${lobbyId} nie istnieje - usuwanie timer`);
                    this.activeTimers.delete(lobbyId);
                    continue;
                }

                timersToRestore.push({ lobbyId, timerData, lobby });
            }

            // Przywr√≥ƒá timery
            for (const { lobbyId, timerData, lobby } of timersToRestore) {
                const warningCallback = async (lobbyId) => {
                    try {
                        const thread = await sharedState.client.channels.fetch(lobby.threadId);
                        
                        // Utw√≥rz przyciski dla w≈Ça≈õciciela lobby
                        const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require('discord.js');
                        const warningButtons = new ActionRowBuilder()
                            .addComponents(
                                new ButtonBuilder()
                                    .setCustomId(`extend_lobby_${lobbyId}`)
                                    .setLabel('Przed≈Çu≈º o 15 min')
                                    .setEmoji('‚è∞')
                                    .setStyle(ButtonStyle.Primary),
                                new ButtonBuilder()
                                    .setCustomId(`close_lobby_${lobbyId}`)
                                    .setLabel('Zamknij lobby')
                                    .setEmoji('üîí')
                                    .setStyle(ButtonStyle.Danger)
                            );

                        await thread.send({
                            content: this.config.messages.lobbyWarning,
                            components: [warningButtons]
                        });
                    } catch (error) {
                        logger.error(`‚ùå B≈ÇƒÖd podczas wysy≈Çania ostrze≈ºenia dla lobby ${lobbyId}:`, error);
                    }
                };

                const deleteCallback = async () => {
                    try {
                        await this.deleteLobby(lobby, sharedState);
                    } catch (error) {
                        logger.error(`‚ùå B≈ÇƒÖd podczas usuwania lobby ${lobbyId}:`, error);
                    }
                };

                // Usu≈Ñ stary timer z mapy i utw√≥rz nowy
                this.activeTimers.delete(lobbyId);
                await this.createLobbyTimer(lobbyId, timerData.createdAt, warningCallback, deleteCallback);
            }

            await this.saveTimersToFile();
            logger.info(`üîÑ Przywr√≥cono ${timersToRestore.length} timer√≥w lobby`);

        } catch (error) {
            logger.error('‚ùå B≈ÇƒÖd podczas przywracania timer√≥w:', error);
        }
    }

    /**
     * Usuwa lobby (kopiowane z interactionHandlers.js)
     * @param {Object} lobby - Dane lobby
     * @param {Object} sharedState - Wsp√≥≈Çdzielony stan aplikacji
     */
    async deleteLobby(lobby, sharedState) {
        try {
            // Usu≈Ñ wƒÖtek
            const thread = await sharedState.client.channels.fetch(lobby.threadId).catch(() => null);
            if (thread) {
                await thread.delete('Czas lobby up≈ÇynƒÖ≈Ç');
            }

            // Usu≈Ñ wiadomo≈õƒá og≈ÇoszeniowƒÖ
            const channel = await sharedState.client.channels.fetch(sharedState.config.channels.party);
            const announcementMessage = await channel.messages.fetch(lobby.announcementMessageId).catch(() => null);
            if (announcementMessage) {
                await announcementMessage.delete();
            }

            // Usu≈Ñ lobby z serwisu
            sharedState.lobbyService.removeLobby(lobby.id);

            // Usu≈Ñ timer
            this.removeTimer(lobby.id);

            logger.info(`üóëÔ∏è Usuniƒôto lobby ${lobby.id} wraz z zasobami (timer expired)`);
        } catch (error) {
            logger.error('‚ùå B≈ÇƒÖd podczas usuwania lobby przez timer:', error);
        }
    }

    /**
     * Zapisuje aktywne timery do pliku
     */
    async saveTimersToFile() {
        try {
            const timersForSave = {};
            
            for (const [lobbyId, timerData] of this.activeTimers.entries()) {
                timersForSave[lobbyId] = {
                    lobbyId: timerData.lobbyId,
                    createdAt: timerData.createdAt,
                    warningTime: timerData.warningTime,
                    deleteTime: timerData.deleteTime,
                    warningExecuted: timerData.warningExecuted,
                    isFullLobby: timerData.isFullLobby || false
                };
            }

            await fs.writeFile(this.dataPath, JSON.stringify(timersForSave, null, 2));
        } catch (error) {
            logger.error('‚ùå B≈ÇƒÖd podczas zapisywania timer√≥w do pliku:', error);
        }
    }

    /**
     * Wczytuje timery z pliku
     */
    async loadTimersFromFile() {
        try {
            const data = await fs.readFile(this.dataPath, 'utf8');
            const timersData = JSON.parse(data);
            
            this.activeTimers.clear();
            
            for (const [lobbyId, timerData] of Object.entries(timersData)) {
                this.activeTimers.set(lobbyId, timerData);
            }
            
            logger.info(`üìÇ Wczytano ${Object.keys(timersData).length} timer√≥w z pliku`);
        } catch (error) {
            if (error.code === 'ENOENT') {
                logger.info('üìÇ Brak pliku timer√≥w - rozpoczynanie z pustƒÖ listƒÖ');
            } else {
                logger.error('‚ùå B≈ÇƒÖd podczas wczytywania timer√≥w:', error);
            }
        }
    }

    /**
     * Pobiera informacje o aktywnych timerach
     * @returns {Array} - Lista aktywnych timer√≥w
     */
    getActiveTimers() {
        const now = Date.now();
        return Array.from(this.activeTimers.entries()).map(([lobbyId, timerData]) => ({
            lobbyId,
            timeRemaining: Math.max(0, timerData.deleteTime - now),
            warningExecuted: timerData.warningExecuted
        }));
    }
}

module.exports = TimerService;