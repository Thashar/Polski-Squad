const { EmbedBuilder } = require('discord.js');

/**
 * Serwis do wykrywania spamu z linkami zewnƒôtrznymi
 */
class SpamDetectionService {
    constructor(config, logger) {
        this.config = config;
        this.logger = logger;
        
        // Przechowywanie wiadomo≈õci z linkami: userId -> Array<{content, timestamp, messageId, channelId}>
        this.userMessages = new Map();
        
        // Konfiguracja z config.js
        this.enabled = config.spamDetection?.enabled ?? true;
        this.maxDuplicates = config.spamDetection?.maxDuplicates ?? 3;
        this.timeWindow = config.spamDetection?.timeWindow ?? (30 * 60 * 1000);
        this.timeoutDuration = config.spamDetection?.timeoutDuration ?? (7 * 24 * 60 * 60 * 1000);
        this.alertChannelId = config.spamDetection?.alertChannelId ?? '1173653205557719140';
        
        // Czyszczenie co 5 minut
        setInterval(() => {
            this.cleanupOldMessages();
        }, 5 * 60 * 1000);
        
        this.logger.info(`üîç SpamDetectionService zainicjalizowany - wykrywanie duplikat√≥w/podobnych wiadomo≈õci z linkami (timeout: ${this.timeoutDuration / (24 * 60 * 60 * 1000)} dni)`);
    }
    
    /**
     * Sprawdza wiadomo≈õƒá pod kƒÖtem spamu z linkami
     * @param {Message} message - Wiadomo≈õƒá Discord
     * @returns {Object} Wynik analizy {isSpam, action, duplicateCount}
     */
    async processMessage(message) {
        // Sprawd≈∫ czy detekcja spamu jest w≈ÇƒÖczona
        if (!this.enabled) {
            return { isSpam: false, action: 'disabled' };
        }
        
        // Ignoruj tylko boty i administrator√≥w (nie moderator√≥w)
        if (message.author.bot || 
            message.member?.permissions.has('Administrator')) {
            return { isSpam: false, action: 'ignore' };
        }
        
        // Sprawd≈∫ czy wiadomo≈õƒá zawiera linki zewnƒôtrzne lub zaproszenia Discord
        const suspiciousLinks = this.extractSuspiciousLinks(message.content);
        if (suspiciousLinks.length === 0) {
            return { isSpam: false, action: 'ignore' };
        }
        
        const userId = message.author.id;
        const now = Date.now();
        
        // Pobierz historiƒô wiadomo≈õci u≈ºytkownika
        if (!this.userMessages.has(userId)) {
            this.userMessages.set(userId, []);
        }
        
        const userHistory = this.userMessages.get(userId);
        
        // Usu≈Ñ stare wiadomo≈õci (poza oknem czasowym)
        const recentMessages = userHistory.filter(msg => 
            now - msg.timestamp < this.timeWindow
        );
        
        // Sprawd≈∫ duplikaty (identyczne i podobne wiadomo≈õci z linkami)
        const duplicates = recentMessages.filter(msg => 
            this.areMessagesSimilar(msg.content, message.content)
        );
        
        const duplicateCount = duplicates.length + 1; // +1 za aktualnƒÖ wiadomo≈õƒá
        
        // Dodaj aktualnƒÖ wiadomo≈õƒá do historii
        recentMessages.push({
            content: message.content,
            timestamp: now,
            messageId: message.id,
            channelId: message.channel.id
        });
        
        // Zaktualizuj historiƒô u≈ºytkownika
        this.userMessages.set(userId, recentMessages);
        
        this.logger.info(`üîç ${message.author.tag} - duplikaty/podobne z linkami: ${duplicateCount}/${this.maxDuplicates}`);
        
        // Je≈õli osiƒÖgniƒôto limit duplikat√≥w
        if (duplicateCount >= this.maxDuplicates) {
            this.logger.warn(`üö® SPAM DETECT: ${message.author.tag} wys≈Ça≈Ç ${duplicateCount} identycznych/podobnych wiadomo≈õci z linkami/zaproszeniami`);
            
            return {
                isSpam: true,
                action: 'timeout',
                duplicateCount: duplicateCount,
                duplicateMessages: [...duplicates, {
                    content: message.content,
                    timestamp: now,
                    messageId: message.id,
                    channelId: message.channel.id
                }]
            };
        }
        
        return { isSpam: false, action: 'monitor', duplicateCount };
    }
    
    /**
     * WyciƒÖga podejrzane linki z wiadomo≈õci (zewnƒôtrzne + zaproszenia Discord)
     * @param {string} content - Tre≈õƒá wiadomo≈õci
     * @returns {Array} Tablica znalezionych link√≥w
     */
    extractSuspiciousLinks(content) {
        const links = [];
        
        // 1. Linki zewnƒôtrzne (nie Discord)
        const externalUrlRegex = /https?:\/\/(?!(?:discord\.gg|discord\.com|discordapp\.com))[^\s]+/gi;
        const externalLinks = content.match(externalUrlRegex) || [];
        links.push(...externalLinks);
        
        // 2. Zaproszenia Discord (wszystkie formy)
        const discordInviteRegex = /(?:https?:\/\/)?(?:www\.)?(?:discord\.gg|discord\.com\/invite|discordapp\.com\/invite)\/[a-zA-Z0-9]+/gi;
        const discordInvites = content.match(discordInviteRegex) || [];
        links.push(...discordInvites);
        
        return links;
    }
    
    /**
     * WyciƒÖga linki zewnƒôtrzne z wiadomo≈õci (stara funkcja - zachowana dla kompatybilno≈õci)
     * @param {string} content - Tre≈õƒá wiadomo≈õci
     * @returns {Array} Tablica znalezionych link√≥w
     */
    extractExternalLinks(content) {
        return this.extractSuspiciousLinks(content);
    }
    
    /**
     * Normalizuje wiadomo≈õƒá do por√≥wnania (usuwa bia≈Çe znaki, zmienia na ma≈Çe litery)
     * @param {string} content - Tre≈õƒá wiadomo≈õci
     * @returns {string} Znormalizowana tre≈õƒá
     */
    normalizeMessage(content) {
        return content.toLowerCase().replace(/\s+/g, ' ').trim();
    }
    
    /**
     * Sprawdza podobie≈Ñstwo wiadomo≈õci z linkami (dla ukrytych link√≥w w d≈Çugim tek≈õcie)
     * @param {string} content1 - Pierwsza wiadomo≈õƒá
     * @param {string} content2 - Druga wiadomo≈õƒá
     * @returns {boolean} Czy wiadomo≈õci sƒÖ podobne
     */
    areMessagesSimilar(content1, content2) {
        const normalized1 = this.normalizeMessage(content1);
        const normalized2 = this.normalizeMessage(content2);
        
        // Je≈õli wiadomo≈õci sƒÖ identyczne
        if (normalized1 === normalized2) {
            return true;
        }
        
        // WyciƒÖgnij linki z obu wiadomo≈õci
        const links1 = this.extractSuspiciousLinks(content1);
        const links2 = this.extractSuspiciousLinks(content2);
        
        // Je≈õli nie ma link√≥w w obu, nie por√≥wnuj
        if (links1.length === 0 || links2.length === 0) {
            return false;
        }
        
        // Sprawd≈∫ czy majƒÖ wsp√≥lne linki
        const commonLinks = links1.filter(link => links2.includes(link));
        if (commonLinks.length === 0) {
            return false;
        }
        
        // Usu≈Ñ linki z wiadomo≈õci i por√≥wnaj pozosta≈Çy tekst
        let text1 = content1;
        let text2 = content2;
        
        // Usu≈Ñ wszystkie podejrzane linki
        const allLinks = [...new Set([...links1, ...links2])];
        for (const link of allLinks) {
            const escapedLink = link.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            text1 = text1.replace(new RegExp(escapedLink, 'gi'), '');
            text2 = text2.replace(new RegExp(escapedLink, 'gi'), '');
        }
        
        // Normalizuj teksty po usuniƒôciu link√≥w
        const normalizedText1 = this.normalizeMessage(text1);
        const normalizedText2 = this.normalizeMessage(text2);
        
        // Je≈õli teksty sƒÖ bardzo podobne (minimum 70% podobie≈Ñstwa)
        const similarity = this.calculateTextSimilarity(normalizedText1, normalizedText2);
        
        this.logger.info(`üîç Podobie≈Ñstwo tekst√≥w: ${(similarity * 100).toFixed(1)}% (${similarity >= 0.7 ? 'PODOBNE' : 'r√≥≈ºne'})`);
        
        return similarity >= 0.7; // 70% podobie≈Ñstwa
    }
    
    /**
     * Oblicza podobie≈Ñstwo miƒôdzy dwoma tekstami (algorytm Jaro-Winkler uproszczony)
     * @param {string} text1 - Pierwszy tekst
     * @param {string} text2 - Drugi tekst  
     * @returns {number} Podobie≈Ñstwo od 0 do 1
     */
    calculateTextSimilarity(text1, text2) {
        if (text1 === text2) return 1.0;
        if (text1.length === 0 && text2.length === 0) return 1.0;
        if (text1.length === 0 || text2.length === 0) return 0.0;
        
        // Uproszczony algorytm podobie≈Ñstwa oparty na wsp√≥lnych s≈Çowach
        const words1 = text1.split(' ').filter(w => w.length > 2);
        const words2 = text2.split(' ').filter(w => w.length > 2);
        
        if (words1.length === 0 && words2.length === 0) return 1.0;
        if (words1.length === 0 || words2.length === 0) return 0.0;
        
        const commonWords = words1.filter(word => words2.includes(word));
        const totalWords = new Set([...words1, ...words2]).size;
        
        return commonWords.length / totalWords;
    }
    
    /**
     * Wykonuje akcje antyspamowe
     * @param {Message} message - Wiadomo≈õƒá Discord
     * @param {Object} result - Wynik analizy spamu
     */
    async executeAntiSpamActions(message, result) {
        if (!result.isSpam || result.action !== 'timeout') {
            return;
        }
        
        try {
            // 1. Usu≈Ñ wszystkie duplikaty wiadomo≈õci
            await this.deleteSpamMessages(message, result.duplicateMessages);
            
            // 2. Daj timeout u≈ºytkownikowi
            await this.timeoutUser(message.member);
            
            // 3. Wy≈õlij powiadomienie na kana≈Ç administracyjny
            await this.sendAlertNotification(message, result);
            
            this.logger.success(`‚úÖ Wykonano akcje antyspamowe dla ${message.author.tag}`);
            
        } catch (error) {
            this.logger.error(`‚ùå B≈ÇƒÖd podczas wykonywania akcji antyspamowych: ${error.message}`);
        }
    }
    
    /**
     * Usuwa spam wiadomo≈õci
     * @param {Message} currentMessage - Aktualna wiadomo≈õƒá
     * @param {Array} duplicateMessages - Lista duplikat√≥w do usuniƒôcia
     */
    async deleteSpamMessages(currentMessage, duplicateMessages) {
        let deletedCount = 0;
        
        for (const msgData of duplicateMessages) {
            try {
                const channel = currentMessage.guild.channels.cache.get(msgData.channelId);
                if (channel) {
                    const message = await channel.messages.fetch(msgData.messageId).catch(() => null);
                    if (message) {
                        await message.delete();
                        deletedCount++;
                        this.logger.info(`üóëÔ∏è Usuniƒôto spam wiadomo≈õƒá ${msgData.messageId} z kana≈Çu #${channel.name}`);
                    }
                }
            } catch (error) {
                this.logger.warn(`‚ö†Ô∏è Nie mo≈ºna usunƒÖƒá wiadomo≈õci ${msgData.messageId}: ${error.message}`);
            }
        }
        
        this.logger.info(`üóëÔ∏è Usuniƒôto ${deletedCount}/${duplicateMessages.length} spam wiadomo≈õci`);
    }
    
    /**
     * Daje timeout u≈ºytkownikowi
     * @param {GuildMember} member - Cz≈Çonek do timeout
     */
    async timeoutUser(member) {
        try {
            const timeoutUntil = new Date(Date.now() + this.timeoutDuration);
            await member.timeout(this.timeoutDuration, 'Spam z linkami zewnƒôtrznymi/zaproszeniami Discord - automatyczny timeout');
            
            this.logger.warn(`‚è∞ Timeout na 7 dni dla ${member.user.tag} do ${timeoutUntil.toLocaleString('pl-PL')}`);
        } catch (error) {
            this.logger.error(`‚ùå Nie mo≈ºna daƒá timeout ${member.user.tag}: ${error.message}`);
            throw error;
        }
    }
    
    /**
     * Wysy≈Ça powiadomienie na kana≈Ç administracyjny
     * @param {Message} message - Oryginalna wiadomo≈õƒá
     * @param {Object} result - Wynik analizy spamu
     */
    async sendAlertNotification(message, result) {
        try {
            const alertChannel = message.guild.channels.cache.get(this.alertChannelId);
            if (!alertChannel) {
                this.logger.warn(`‚ö†Ô∏è Nie znaleziono kana≈Çu alert√≥w: ${this.alertChannelId}`);
                return;
            }
            
            const timeoutEnd = new Date(Date.now() + this.timeoutDuration);
            
            const embed = new EmbedBuilder()
                .setTitle('üö® SPAM DETECTED - Automatyczny Timeout')
                .setColor('#ff4444')
                .setDescription(`U≈ºytkownik wys≈Ça≈Ç ${result.duplicateCount} identycznych/podobnych wiadomo≈õci z linkami zewnƒôtrznymi lub zaproszeniami Discord`)
                .addFields(
                    {
                        name: 'üë§ U≈ºytkownik',
                        value: `${message.author.tag} (<@${message.author.id}>)\nID: \`${message.author.id}\``,
                        inline: true
                    },
                    {
                        name: '‚è∞ Timeout do',
                        value: `<t:${Math.floor(timeoutEnd.getTime() / 1000)}:F>\n(<t:${Math.floor(timeoutEnd.getTime() / 1000)}:R>)`,
                        inline: true
                    },
                    {
                        name: 'üìä Statystyki',
                        value: `**Duplikaty:** ${result.duplicateCount}/${this.maxDuplicates}\n**Czas okna:** ${this.timeWindow / 60000} min\n**Czas timeout:** ${this.timeoutDuration / (24 * 60 * 60 * 1000)} dni`,
                        inline: true
                    },
                    {
                        name: 'üí¨ Tre≈õƒá spam wiadomo≈õci',
                        value: message.content.length > 1024 ? 
                            message.content.substring(0, 1020) + '...' : 
                            message.content,
                        inline: false
                    },
                    {
                        name: 'üîó Wykryte linki',
                        value: this.extractSuspiciousLinks(message.content).join('\n') || 'Brak',
                        inline: false
                    }
                )
                .setFooter({ 
                    text: `Muteusz Bot - Automatyczna detekcja spamu` 
                })
                .setTimestamp();
            
            await alertChannel.send({ embeds: [embed] });
            
            this.logger.success(`üì¢ Wys≈Çano powiadomienie o spam na kana≈Ç ${alertChannel.name}`);
            
        } catch (error) {
            this.logger.error(`‚ùå B≈ÇƒÖd wysy≈Çania powiadomienia: ${error.message}`);
        }
    }
    
    /**
     * Czy≈õci stare wiadomo≈õci z pamiƒôci
     */
    cleanupOldMessages() {
        const now = Date.now();
        let totalCleaned = 0;
        
        for (const [userId, messages] of this.userMessages.entries()) {
            const recentMessages = messages.filter(msg => 
                now - msg.timestamp < this.timeWindow
            );
            
            const cleanedCount = messages.length - recentMessages.length;
            totalCleaned += cleanedCount;
            
            if (recentMessages.length === 0) {
                this.userMessages.delete(userId);
            } else {
                this.userMessages.set(userId, recentMessages);
            }
        }
        
        if (totalCleaned > 0) {
            this.logger.info(`üßπ Wyczyszczono ${totalCleaned} starych wiadomo≈õci z pamiƒôci`);
        }
    }
    
    /**
     * Pobiera statystyki serwisu
     * @returns {Object} Statystyki
     */
    getStats() {
        const totalUsers = this.userMessages.size;
        let totalMessages = 0;
        
        for (const messages of this.userMessages.values()) {
            totalMessages += messages.length;
        }
        
        return {
            monitoredUsers: totalUsers,
            totalMessages: totalMessages,
            timeWindow: this.timeWindow / 60000, // w minutach
            maxDuplicates: this.maxDuplicates,
            timeoutDuration: this.timeoutDuration / (24 * 60 * 60 * 1000) // w dniach
        };
    }
}

module.exports = SpamDetectionService;